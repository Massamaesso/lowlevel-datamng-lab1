Exercise 2:  System calls Description
Systems calls description of echo, ls  commands and a hello world C file :
execve(): execve() executes the program referred to by pathname.  This causes
           the program that is currently being run by the calling process to be
           replaced with a new program, with newly initialized stack, heap, and
           (initialized and uninitialized) data segments.


           pathname must be either a binary executable, or a script starting
           with a line of the form:


               #!interpreter [optional-arg]


           For details of the latter case, see "Interpreter scripts" below.


           argv is an array of pointers to strings passed to the new program as
           its command-line arguments.  By convention, the first of these
           strings (i.e., argv[0]) should contain the filename associated with
           the file being executed.  The argv array must be terminated by a NULL
           pointer.  (Thus, in the new program, argv[argc] will be NULL.)


           envp is an array of pointers to strings, conventionally of the form
           key=value, which are passed as the environment of the new program.
           The envp array must be terminated by a NULL pointer.


           The argument vector and environment can be accessed by the new pro‐
           gram's main function, when it is defined as:


               int main(int argc, char *argv[], char *envp[])


           Note, however, that the use of a third argument to the main function
           is not specified in POSIX.1; according to POSIX.1, the environment
           should be accessed via the external variable environ(7).


           execve() does not return on success, and the text, initialized data,
           uninitialized data (bss), and stack of the calling process are over‐
           written according to the contents of the newly loaded program.


           If the current program is being ptraced, a SIGTRAP signal is sent to
           it after a successful execve().


           If the set-user-ID bit is set on the program file referred to by
           pathname, then the effective user ID of the calling process is
           changed to that of the owner of the program file.  Similarly, if the
           set-group-ID bit is set on the program file, then the effective group
           ID of the calling process is set to the group of the program file.


           The aforementioned transformations of the effective IDs are not per‐
           formed (i.e., the set-user-ID and set-group-ID bits are ignored) if
           any of the following is true:


           *  the no_new_privs attribute is set for the calling thread (see
              prctl(2));


           *  the underlying filesystem is mounted nosuid (the MS_NOSUID flag
              for mount(2)); or


           *  the calling process is being ptraced.


           The capabilities of the program file (see capabilities(7)) are also
           ignored if any of the above are true.


           The effective user ID of the process is copied to the saved set-user-
           ID; similarly, the effective group ID is copied to the saved set-
           group-ID.  This copying takes place after any effective ID changes
           that occur because of the set-user-ID and set-group-ID mode bits.


           The process's real UID and real GID, as well its supplementary group
           IDs, are unchanged by a call to execve().


           If the executable is an a.out dynamically linked binary executable
           containing shared-library stubs, the Linux dynamic linker ld.so(8) is
           called at the start of execution to bring needed shared objects into
           memory and link the executable with them.


           If the executable is a dynamically linked ELF executable, the inter‐
           preter named in the PT_INTERP segment is used to load the needed
           shared objects.  This interpreter is typically /lib/ld-linux.so.2 for
           binaries linked with glibc (see ld-linux.so(8)).


brk() : brk() and sbrk() change the location of the program break, which defines the end of the process's data segment (i.e., the program break is the first location after the end of the uninitialized data segment).  Increasing the program break has the effect of allocating memory to the process; decreasing the break deallocates memory.
 brk() sets the end of the data segment to the value specified by addr, when that value is reasonable, the system has enough memory and the process does not exceed its maximum data size. sbrk() increments the program's data space by increment bytes.Calling sbrk() with an increment of 0 can be used to find the current location of the program break.


access(): access() checks whether the calling process can access the file pathname.If pathname is a symbolic link, it is dereferenced.The mode specifies the accessibility check(s) to be performed, and is either the value F_OK, or a mask consisting of the bitwise OR of one or more of R_OK, W_OK, and X_OK.  F_OK tests for the existence of the file.  R_OK, W_OK, and X_OK test whether the file exists and grants read, write, and execute permissions, respectively.The check is done using the calling process's real UID and GID,rather than the effective IDs as is done when actually attempting an operation (e.g., open(2)) on the file.  Similarly, for the root user,the check uses the set of permitted capabilities rather than the set of effective capabilities; and for non-root users, the check uses an empty set of capabilities.This allows set-user-ID programs and capability-endowed programs to easily determine the invoking user's authority.  In other words, access() does not answer the "can I read/write/execute this file?" question.  It answers a slightly different question: "(assuming I'm a setuid binary) can the user who invoked me read/write/execute this file?", which gives set-user-ID programs the possibility to prevent malicious users from causing them to read files which users shouldn't be able to read.If the calling process is privileged (i.e., its real UID is zero),then an X_OK check is successful for a regular file if execute permission is enabled for any of the file owner, group, or other.The faccessat() system call operates in exactly the same way as access(), except for the differences described here.If the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done by access() for a relative pathname).If pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the current working directory of the calling process (like access()).If pathname is absolute, then dirfd is ignored.flags is constructed by ORing together zero or more of the following
values:AT_EACCESS Perform access checks using the effective user and group IDs.By default, faccessat() uses the real IDs (like access()).AT_SYMLINK_NOFOLLOW If pathname is a symbolic link, do not dereference it: instead return information about the link itself.See openat(2) for an explanation of the need for faccessat().








open(): opens and possibly create a file


fstat(): gets file status
mmap(): map or unmap files or devices into memory.
mprotect():set protection on a region of memory
munmap(): map or unmap files or devices into memory
close(): close a file descriptor
read(): read from a file descriptor
arch_prctl():set architecture-specific thread state
ioctl(): The ioctl() system call manipulates the underlying device parameters
           of special files.  In particular, many operating characteristics of
           character special files (e.g., terminals) may be controlled with
           ioctl() requests.  The argument fd must be an open file descriptor.


           The second argument is a device-dependent request code.  The third
           argument is an untyped pointer to memory.  It's traditionally char
           *argp (from the days before void * was valid C), and will be so named
           for this discussion.


           An ioctl() request has encoded in it whether the argument is an in
           parameter or out parameter, and the size of the argument argp in
           bytes.  Macros and defines used in specifying an ioctl() request are
           located in the file <sys/ioctl.h>.  See NOTES.
getdents():get directory entries
write(): write to a file descriptor
exit_group(): exit all threads in a process.
